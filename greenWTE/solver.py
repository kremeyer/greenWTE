"""User-facing module for solving the Wigner Transport Equation (WTE) with a source term.

This module provides a command-line interface to run the WTE solver with various parameters, including temperature,
spatial frequency, and temporal frequency range. It reads input data from an HDF5 file generated by phono3py and writes
the results to an output HDF5 file. It uses the `Solver` class from the `lib_experimental` module to perform the
calculations and save the results.
"""

from argparse import ArgumentParser

import cupy as cp
import h5py
from scipy.constants import elementary_charge

from . import sources
from .lib import Solver


def parse_arguments():
    """Parse command-line arguments."""
    parser = ArgumentParser(description="WTE Solver")

    parser.add_argument("input", type=str, help="HDF5 input file from phono3py")
    parser.add_argument("output", type=str, help="HDF5 output file")

    parser.add_argument("-t", "--temperature", type=float, default=350.0)
    parser.add_argument("-k", "--spacial_frequency", type=float, default=7, help="spatial frequency in 10^(rad/m)")
    parser.add_argument(
        "-w", "--omega_range", type=float, nargs="+", default=[5, 15, 25], help="temporal frequency range in 10^(Hz)"
    )
    parser.add_argument(
        "-xg", "--exclude_gamma", type=bool, default=True, help="exclude gamma point from the calculation"
    )

    parser.add_argument("-m", "--max_iter", type=int, default=100, help="maximum number of iterations")
    parser.add_argument("-c", "--conv_thr", type=float, default=1e-10, help="convergence threshold")
    parser.add_argument("-sp", "--single_precision", action="store_true", help="use single precision")
    parser.add_argument(
        "-is", "--inner_solver", type=str, choices=["gmres", "cgesv"], default="gmres", help="inner solver to use"
    )
    parser.add_argument(
        "-os",
        "--outer_solver",
        type=str,
        choices=["aitken", "plain", "root"],
        default="aitken",
        help="outer solver to use",
    )
    parser.add_argument(
        "--diag-velocity-operator", action="store_true", help="set offdiagonal elements of velocity operator to zero"
    )
    parser.add_argument(
        "-s",
        "--source-type",
        type=str,
        choices=["diagonal", "diag", "full", "offdiagonal", "offdiag", "gradT", "anticommutator"],
        default="gradT",
        help="structure of source term",
    )
    parser.add_argument(
        "-d",
        "--direction",
        type=str,
        choices=["x", "y", "z"],
        default="x",
        help="direction of the temperature grating vector",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="initialize solver but do not run the calculation; for testing purposes"
    )

    a = parser.parse_args()

    if len(a.omega_range) == 1:
        a.omega_range = cp.array([10 ** (float(a.omega_range[0]))])
    elif len(a.omega_range) == 3:
        a.omega_range[-1] = int(a.omega_range[-1])
        a.omega_range = cp.logspace(*a.omega_range)
    else:
        raise ValueError("omega_range must be a single value or 3 values (start, stop, num)")
    a.omega_range = cp.sort(a.omega_range)[::-1]

    a.spacial_frequency = 10 ** float(a.spacial_frequency)

    return a


def load_phono3py_data(filename, temperature, dir_idx, exclude_gamma=True, dtyper=cp.float64, dtypec=cp.complex128):
    """Load data from a phono3py-generated HDF5 file."""
    with h5py.File(filename, "r") as h5f:
        available_temperatures = list(h5f["temperature"][()])
        if temperature in available_temperatures:
            temperature_index = available_temperatures.index(temperature)
        else:
            raise ValueError(
                f"Temperature {temperature} not found in the input file."
                f"Available temperatures: {available_temperatures}"
            )
        q_idx = int(exclude_gamma)
        velocity_operator = (
            cp.array(h5f["velocity_operator"][q_idx:, ..., dir_idx], dtype=dtypec) * 1e2
        )  # (nq, nat3, nat3) | m/s
        phonon_freq = cp.array(h5f["frequency"][q_idx:], dtype=dtyper) * 1e12 * 2 * cp.pi  # (nq, nat3) | Hz
        linewidth = cp.array(h5f["gamma"][temperature_index, q_idx:], dtype=dtyper)  # (nT, nq, nat3)
        linewidth += cp.array(h5f["gamma_isotope"][q_idx:], dtype=dtyper)  # (nq, nat3)
        linewidth += cp.array(h5f["gamma_boundary"][q_idx:], dtype=dtyper)  # (nq, nat3)
        linewidth *= 1e12 * 2 * cp.pi  # Hz | ordinal to angular frequency
        linewidth *= 2  # HWHM -> FWHM
        volume = cp.array(h5f["volume"][()], dtype=dtyper) * 1e-30  # m^3
        weight = cp.array(h5f["weight"][q_idx:], dtype=dtyper)  # nq | 1
        weight /= cp.sum(weight)
        heat_capacity = (
            cp.array(h5f["heat_capacity"][temperature_index, q_idx:], dtype=dtyper) * elementary_charge
        )  # (nT, nq, nat3) | J/K
        heat_capacity *= weight[:, None] / volume  # (nq, nat3) | J/(K m^3)

    return (
        velocity_operator,
        phonon_freq,
        linewidth,
        heat_capacity,
        volume,
        weight,
    )


def save_solver_result(filename, solver, **kwargs):
    """Save the solver results to an HDF5 file."""
    with h5py.File(filename, "w") as h5f:
        h5f.create_dataset("dT", data=solver.dT.get()[::-1])
        h5f.create_dataset("dT_init", data=solver.dT_init.get()[::-1])
        h5f.create_dataset("n", data=solver.n.get()[::-1])
        h5f.create_dataset("niter", data=solver.niter.get()[::-1])
        h5f.create_dataset("iter_time", data=solver.iter_time.get()[::-1])
        h5f.create_dataset("gmres_residual", data=solver.gmres_residual.get()[::-1])
        h5f.create_dataset("dT_convergence", data=solver.dT_convergence.get()[::-1])
        h5f.create_dataset("n_convergence", data=solver.n_convergence.get()[::-1])
        h5f.create_dataset("source", data=solver.source.get())

        h5f.create_dataset("omega", data=solver.omg_ft_array.get()[::-1])
        h5f.create_dataset("k", data=solver.k_ft)
        h5f.create_dataset("max_iter", data=solver.max_iter)
        h5f.create_dataset("conv_thr", data=solver.conv_thr)
        h5f.create_dataset("dtype_real", data=str(solver.dtyper))
        h5f.create_dataset("dtype_complex", data=str(solver.dtypec))
        h5f.create_dataset("outer_solver", data=solver.outer_solver)
        h5f.create_dataset("inner_solver", data=solver.inner_solver)
        # h5f.create_dataset("diag_velocity_operator", data=solver.command_line_args.diag_velocity_operator)
        # h5f.create_dataset("direction", data=solver.command_line_args.direction)
        # h5f.create_dataset("source_flag", data=solver.command_line_args.source_type)

        for key, value in vars(solver.command_line_args).items():
            print(key, value)
            if key in h5f:
                continue
            if isinstance(value, cp.ndarray):
                h5f.create_dataset(key, data=value.get())
            else:
                h5f.create_dataset(key, data=value)

        for key, value in kwargs.items():
            if isinstance(value, cp.ndarray):
                h5f.create_dataset(key, data=value.get())
            else:
                h5f.create_dataset(key, data=value)


if __name__ == "__main__":
    args = parse_arguments()

    if args.single_precision:
        dtyper = cp.float32
        dtypec = cp.complex64
    else:
        dtyper = cp.float64
        dtypec = cp.complex128

    if cp.finfo(dtyper).resolution > args.conv_thr:
        conv_thr = 2 * cp.finfo(dtyper).resolution
        print(
            f"Warning: convergence threshold {args.conv_thr} is smaller than machine"
            f" precision {cp.finfo(dtyper).resolution}."
        )
        print(f"Using twice machine precision {conv_thr} instead.")

    if args.direction == "x":
        dir_idx = 0
    elif args.direction == "y":
        dir_idx = 1
    elif args.direction == "z":
        dir_idx = 2
    else:
        raise ValueError("Direction must be one of 'x', 'y', or 'z'.")

    velocity_operator, phonon_freq, linewidth, heat_capacity, volume, weight = load_phono3py_data(
        args.input,
        temperature=args.temperature,
        dir_idx=dir_idx,
        exclude_gamma=args.exclude_gamma,
        dtyper=dtyper,
        dtypec=dtypec,
    )

    if args.diag_velocity_operator:
        offdiag_mask = ~cp.eye(velocity_operator.shape[1], dtype=cp.bool_)
        velocity_operator[:, offdiag_mask] = 0

    if args.source_type == "full":
        source = sources.source_term_full(heat_capacity)
    elif args.source_type in ["diagonal", "diag"]:
        source = sources.source_term_diag(heat_capacity)
    elif args.source_type in ["offdiagonal", "offdiag"]:
        source = sources.source_term_offdiag(heat_capacity)
    elif args.source_type == "gradT":
        source = sources.source_term_gradT(
            args.spacial_frequency, velocity_operator, phonon_freq, heat_capacity, volume
        )
    elif args.source_type == "anticommutator":
        source = sources.source_term_anticommutator(
            args.spacial_frequency, velocity_operator, phonon_freq, heat_capacity, volume
        )
    else:
        raise ValueError(f"Unknown source term structure: {args.source_type}")

    solver = Solver(
        omg_ft_array=args.omega_range,
        k_ft=args.spacial_frequency,
        phonon_freq=phonon_freq,
        linewidth=linewidth,
        velocity_operator=velocity_operator,
        heat_capacity=heat_capacity,
        volume=volume,
        source=source,
        max_iter=args.max_iter,
        conv_thr=args.conv_thr,
        dtyper=dtyper,
        dtypec=dtypec,
        outer_solver=args.outer_solver,
        inner_solver=args.inner_solver,
        command_line_args=args,
    )

    if args.dry_run:
        import sys

        sys.exit(0)

    solver.run()

    print(f"kappa_{args.direction}{args.direction} = {cp.real(solver.kappa)} W/m/K")
    print(f"kappa_{args.direction}{args.direction}_P = {cp.real(solver.kappa_p)} W/m/K")
    print(f"kappa_{args.direction}{args.direction}_C = {cp.real(solver.kappa_c)} W/m/K")

    save_solver_result(args.output, solver)
