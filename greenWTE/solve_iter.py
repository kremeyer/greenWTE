"""User-facing module for solving the Wigner Transport Equation (WTE) with a source term.

This module provides a command-line interface to run the iterative greenWTE solver with various parameters, including
temperature, spatial frequency, and temporal frequency range. It reads input data from an HDF5 file generated by
phono3py and writes the results to an output HDF5 file. It uses the :py:class:`.iterative.IterativeWTESolver` class to
perform the calculations and save the results.
"""

from argparse import ArgumentParser

import cupy as cp

from . import sources
from .io import save_solver_result
from .iterative import IterativeWTESolver


def parse_arguments():
    """Parse command-line arguments."""
    parser = ArgumentParser(description="greenWTE iterative solver")

    parser.add_argument("input", type=str, help="HDF5 input file from phono3py")
    parser.add_argument("output", type=str, help="HDF5 output file")

    parser.add_argument("-t", "--temperature", type=float, default=350.0)
    parser.add_argument("-k", "--spatial-frequency", type=float, default=7, help="spatial frequency in 10^(rad/m)")
    parser.add_argument(
        "-w", "--omega-range", type=float, nargs="+", default=[5, 15, 25], help="temporal frequency range in 10^(Hz)"
    )
    parser.add_argument(
        "-xg", "--exclude-gamma", type=bool, default=True, help="exclude gamma point from the calculation"
    )

    parser.add_argument("-m", "--max-iter", type=int, default=100, help="maximum number of iterations")
    parser.add_argument("-cr", "--conv-thr-rel", type=float, default=1e-10, help="relative convergence threshold")
    parser.add_argument("-ca", "--conv-thr-abs", type=float, default=0, help="absolute convergence threshold")
    parser.add_argument("-sp", "--single-precision", action="store_true", help="use single precision")
    parser.add_argument(
        "-is", "--inner-solver", type=str, choices=["gmres", "cgesv"], default="gmres", help="inner solver to use"
    )
    parser.add_argument(
        "-os",
        "--outer-solver",
        type=str,
        choices=["aitken", "plain", "root", "none"],
        default="aitken",
        help="outer solver to use",
    )
    parser.add_argument(
        "--diag-velocity-operator", action="store_true", help="set offdiagonal elements of velocity operator to zero"
    )
    parser.add_argument(
        "-s",
        "--source-type",
        type=str,
        choices=["diagonal", "diag", "full", "offdiagonal", "offdiag", "gradT", "anticommutator"],
        default="gradT",
        help="structure of source term",
    )
    parser.add_argument(
        "-d",
        "--direction",
        type=str,
        choices=["x", "y", "z"],
        default="x",
        help="direction of the temperature grating vector",
    )
    parser.add_argument(
        "-dT",
        "--dT-init",
        type=float,
        nargs=2,
        default=[1.0, 1.0],
        help="real and imaginary parts of the initial guess for temperature change at the first frequency; this value"
        " is used as dT, when outer-solver is chosen as 'none'.",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="initialize solver but do not run the calculation; for testing purposes"
    )

    a = parser.parse_args()

    if len(a.omega_range) == 1:
        a.omega_range = cp.array([10 ** (float(a.omega_range[0]))])
    elif len(a.omega_range) == 3:
        a.omega_range[-1] = int(a.omega_range[-1])
        a.omega_range = cp.logspace(*a.omega_range)
    else:
        raise ValueError("omega_range must be a single value or 3 values (start, stop, num)")
    a.omega_range = cp.sort(a.omega_range)

    a.spatial_frequency = 10 ** float(a.spatial_frequency)

    a.dT_init = tuple(float(x) for x in a.dT_init)

    return a


if __name__ == "__main__":
    from .base import Material

    cp.set_printoptions(
        formatter={
            "complex_kind": lambda z: f"{z: .2e}",
            "float_kind": lambda x: f"{x: .2e}",
        }
    )

    args = parse_arguments()

    if args.single_precision:
        dtyper = cp.float32
        dtypec = cp.complex64
    else:
        dtyper = cp.float64
        dtypec = cp.complex128

    if cp.finfo(dtyper).resolution > args.conv_thr_rel:
        args.conv_thr_rel = 2 * cp.finfo(dtyper).resolution
        print(
            f"Warning: convergence threshold {args.conv_thr_rel} is smaller than machine"
            f" precision {cp.finfo(dtyper).resolution}."
        )
        print(f"Using twice machine precision {args.conv_thr_rel} instead.")

    if cp.finfo(dtyper).resolution > args.conv_thr_abs:
        args.conv_thr_abs = 2 * cp.finfo(dtyper).resolution
        print(
            f"Warning: convergence threshold {args.conv_thr_abs} is smaller than machine"
            f" precision {cp.finfo(dtyper).resolution}."
        )
        print(f"Using twice machine precision {args.conv_thr_abs} instead.")

    if args.direction == "x":
        dir_idx = 0
    elif args.direction == "y":
        dir_idx = 1
    elif args.direction == "z":
        dir_idx = 2
    else:
        raise ValueError("Direction must be one of 'x', 'y', or 'z'.")

    mat = Material.from_phono3py(
        filename=args.input,
        temperature=args.temperature,
        dir_idx=dir_idx,
        dtyper=dtyper,
        dtypec=dtypec,
    )

    if args.diag_velocity_operator:
        offdiag_mask = ~cp.eye(mat.velocity_operator.shape[1], dtype=cp.bool_)
        mat.velocity_operator[:, offdiag_mask] = 0

    if args.source_type == "full":
        source = sources.source_term_full(mat.heat_capacity) * 5e8
        source_type_for_solver = "energy"
    elif args.source_type in ["diagonal", "diag"]:
        source = sources.source_term_diag(mat.heat_capacity)
        source_type_for_solver = "energy"
    elif args.source_type in ["offdiagonal", "offdiag"]:
        source = sources.source_term_offdiag(mat.heat_capacity)
        source_type_for_solver = "energy"
    elif args.source_type == "gradT":
        source = sources.source_term_gradT(
            args.spatial_frequency,
            mat.velocity_operator,
            mat.phonon_freq,
            mat.linewidth,
            mat.heat_capacity,
            mat.volume,
        )
        source_type_for_solver = "gradient"
    elif args.source_type == "anticommutator":
        import warnings

        warnings.warn(
            "The anticommutator source term flag is deprecated and will be removed in future versions. "
            "Please use the gradT source term instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        source = sources.source_term_gradT(
            args.spatial_frequency,
            mat.velocity_operator,
            mat.phonon_freq,
            mat.linewidth,
            mat.heat_capacity,
            mat.volume,
        )
        source_type_for_solver = "gradient"
    else:
        raise ValueError(f"Unknown source term structure: {args.source_type}")

    solver = IterativeWTESolver(
        omg_ft_array=args.omega_range,
        k_ft=args.spatial_frequency,
        material=mat,
        source=source,
        source_type=source_type_for_solver,
        max_iter=args.max_iter,
        conv_thr_rel=args.conv_thr_rel,
        conv_thr_abs=args.conv_thr_abs,
        outer_solver=args.outer_solver,
        inner_solver=args.inner_solver,
        command_line_args=args,
        dT_init=args.dT_init[0] + 1j * args.dT_init[1],
        print_progress=True,
    )

    if args.dry_run:
        import sys

        sys.exit(0)

    solver.run()

    cell_width = 20
    dc = args.direction  # direction character
    header = f"{'frequency':>{cell_width // 2}} "
    header += f"{f'κ_{dc}{dc}':>{cell_width}} "
    header += f"{f'κ_{dc}{dc}_P':>{cell_width}} "
    header += f"{f'κ_{dc}{dc}_C':>{cell_width}} "
    header += f"{f'|κ_{dc}{dc}|':>{cell_width // 2}} "
    header += f"{f'|κ_{dc}{dc}_P|':>{cell_width // 2}} "
    header += f"{f'|κ_{dc}{dc}_C|':>{cell_width // 2}}"
    print("\n", header)
    print(f"{'-' * 107}")
    for i in range(len(solver.omg_ft_array)):
        print(
            f"{solver.omg_ft_array[i]: {(cell_width // 2) + 1}.2e} "
            f"{solver.kappa[i]: {cell_width}.2e} "
            f"{solver.kappa_p[i]: {cell_width}.2e} "
            f"{solver.kappa_c[i]: {cell_width}.2e} "
            f"{cp.abs(solver.kappa[i]): {cell_width // 2}.2e} "
            f"{cp.abs(solver.kappa_p[i]): {cell_width // 2}.2e} "
            f"{cp.abs(solver.kappa_c[i]): {cell_width // 2}.2e}"
        )
    print(f"{'-' * 107}")

    save_solver_result(args.output, solver)
